
## 클로저?
클로저란 함수내부에서 함조하고있는 외부 변수 또는 함수를 가르키며,
참조하고 있는 경우 실행컨택스트에서 사라지지 않고 남아있습니다
마지막으로 클로저는 참조가 남아 있으면 메모리가 계속 증가합니다.
JS 모듈을 만들 때 클로저를 이용하면
전역을 더럽히지 않고
네임스페이스 충돌을 걱정할 필요도 없이
그 모듈 내에 변수를 정의해 쓸 수 있습니다.

## 실행컨텍스트?

## 호이스팅?

## 비동기?

기존 비동기 호출은 그 비동기 호출이 완료되는 순간
즉시 작업 큐에 올라간다. 비동기 콜백안에 다른 비동기가 들어오는 이유!
반면에 프로미스는 해결 이후에 다음 일을 할 시점을 제어 할 수 있다.
비동기-비동기, 비동기-동기 코드가 같이 실행될 때.
한 비동기가 끝나고, 콜백을 실행할 준비가 되었을 때,
동기화된 코드가 종료되어 있다는 보장이 없다.
그래서 콜백 안에서 다음 준비를 하게된다.

## 브라우저/ 자바스크립트 엔진
문과 식이 번갈아 나오는 코드는, 같은 식,문 끼리 나오는 경우보다
느리게 동작하고 메모리를 더 많이 소비한다.

## 이벤트 버블링/ 캡쳐링/ 위임

## http/ https 차이

## 캐싱이란?

## CSR SSR 차이

## 브라우저 스토리지?

## 모듈 번들러?

## CORS?

## 가상 DOM? 

## SEO? 

## reflow repaint
 - reflow
    
 - repaint 

div>span여러개 
    상위 div최종적으로 판단됨 geometry
    상위는 자식엘리먼트의 영향을 받음
    형제들은 자기 형 노드의 영향을 받음
    어떻게 적게할것인가? 변경사항을 한쪽으로 몰아준다. 
    자주일어날 곳은 브라우저에서 디바운싱한다. 유발인자들만 한 함수에 작성.
```
div.style.width = '96px';
let c = a + b;
div.style.height = '48px'
```
position이 absolute인경우는 자식에만 영향.
전체 리플로우를 막울수 있다.

```
div.getBoundingClientRect()
div.offsetWidth
div.getComputedStyle();

```
호출되는 수만큼 리플로우가 일어난다. 필요한 순간 몰아서 계산해야한다.
정확한 정보를 찾기위함으로, 다시 그리는 것이아니라repaint가 일어나지 않는다.

-> reflow ( 쨉 )


결과로, 엘리먼트가 변해서 새로 그려줘야한다
값이 더 비싸다.(실행비용이 비쌈) 캔버스위에
svg, html 에니메이션!! 회피방법이 거의 없다. 그래서 리플로우 관련 방법이 많다.
-> repaint ( 스트레잇 )
    
주사율 -> 하지만소프트웨어는 갱신요소가 없으면   아무것도 안함.

뭐가 더비싸냐는 언급안해도 된다.

## 디자인시스템
- 다만 이 회사가 전체적인 디자인을 몇번을 바꾸워왔는지 몇개의 디자인 시스템을 가져왔는지?
- mvp패턴의 문제점은 공수가 많이든다.
- 디자인시스템을 적용한다는 순간 아이덴티티가 일정해야한다. 디자이너가 낄 틈이없다.

## 프레임워크

vuejs가 플로우를 많이 제어한다 제어역전(내가 개발하지 않은 부분이 구현이 되는것. 일이 실행되는순서에 관여하는것이 프레임워크.) 라이프싸이클을 간접적으로 다뤄질수밖에없기에 프레임워크이다.마크업 템플릿을 컴파일 

## mvvm 패턴

### 추가내용
msa가되면 모든 에이피아이를 합집합으로 보여주는 스케마를 정의했을때 프론트에서 필요한 스케마만을 요청.

그래프큐엘이 의도대로 사용되려면
똑같은 근간의 데이터를 사용자의 액터에따라 서비스를 제공, 5개서비스가 예로, 
구조상으로는 서버4명에 프론트는 15명이면 그래프큐엘이좋다
